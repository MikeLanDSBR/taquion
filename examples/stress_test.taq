package main

// Constantes globais
const MAX_PRINTS = 5;
const PLAYER_LEVEL = 10;

// Exemplo de função recursiva: Fibonacci
// Testa: functions_test, function_recursion, if_statement
func fibonacci(n) {
    if (n < 2) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// Verifica se um número é primo
// Testa: while_loop, break_continue, math_precendence (modulo), bool_test
func isPrime(n) {
    if (n <= 1) { return false; }
    if (n <= 3) { return true; }
    if ((n % 2) == 0) { return false; }
    if ((n % 3) == 0) { return false; }

    let i = 5;
    while (i * i <= n) {
        if ((n % i) == 0) {
            return false;
        }
        i = i + 2; // Otimização simples para pular números pares
    }
    return true;
}

func main() {
    // === Teste Básico de Impressão e Strings ===
    print("--- Iniciando Teste de Capacidade do TaquionC ---");
    let world_word = "Mundo";
    let hello_message = "Olá, " + world_word + "!"; // Testa: string_concat
    print(hello_message);
    print(""); // Imprime linha em branco para espaçamento

    // === Teste de Recursão e Funções ===
    print("--- Testando Funções e Recursão ---");
    let fib_num = 9;
    print("O número de Fibonacci para " + "9" + " é:"); // Note: Conversão de int para string não implementada, concatenando strings
    print(fibonacci(fib_num)); // Deve imprimir 34
    print("");

    // === Teste de Loops, Condicionais e Booleanos ===
    print("--- Testando Loops, Condicionais e Booleanos ---");
    print("Procurando os primeiros " + "5" + " números primos depois de 10:");
    let count = 0;
    let current_num = 11;
    while (true) {
        if (count >= MAX_PRINTS) {
            print("Busca de primos finalizada.");
            break; // Testa: break
        }

        if (isPrime(current_num)) {
            print("Primo encontrado:");
            print(current_num);
            count = count + 1;
        } else {
            // Apenas para usar o continue
            current_num = current_num + 1;
            continue; // Testa: continue
        }
        current_num = current_num + 1;
    }
    print("");

    // === Teste de Arrays e Atribuição ===
    print("--- Testando Arrays ---");
    let inventory = [101, 205, 301, 0, 0]; // Simula IDs de itens, testa: array_basic
    print("ID do item no slot 1:");
    print(inventory[1]); // Deve imprimir 205

    print("Substituindo item no slot 1...");
    inventory[1] = 210; // Testa: atribuição de índice de array
    print("Novo ID do item no slot 1:");
    print(inventory[1]); // Deve imprimir 210
    print("");

    // === Teste de Escopo e Precedência Matemática ===
    print("--- Testando Escopo e Matemática ---");
    let base_damage = 50;
    // Testa: scope_shadowing
    if (true) {
        let base_damage = 10; // Sombreia a variável externa
        let total_damage = base_damage + PLAYER_LEVEL * 2; // Testa: math_precendence (* antes de +)
        print("Dano calculado no escopo interno (deve ser 10 + 10 * 2 = 30):");
        print(total_damage);
    }
    let total_damage = base_damage + PLAYER_LEVEL * 3; // Usa a variável externa
    print("Dano calculado no escopo externo (deve ser 50 + 10 * 3 = 80):");
    print(total_damage);
    print("");

    print("--- Teste de Capacidade Concluído ---");
    return 0; // Testa: start
}